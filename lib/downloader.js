// Generated by CoffeeScript 1.10.0
(function () {
    var Downloader, Error, EventEmitter, Log, Path, Playlist, SpotifyWeb, Success, Track, async, colors, domain, id3, fs, lodash, mkdirp, program, util,
        bind = function (fn, me) { return function () { return fn.apply(me, arguments); }; },
        extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;
    
    require('coffee-script');
    
    fs = require('fs');
    
    async = require('async');
    
    lodash = require('lodash');
    
    util = require('util');
    
    colors = require('colors');
    
    SpotifyWeb = require('spotify-web');
    
    mkdirp = require('mkdirp');
    
    Path = require('path');
    
    program = require('commander');
    
    id3 = require('node-id3');
    
    domain = require('domain');
    
    EventEmitter = require('events').EventEmitter;
    
    Error = (function (_this) {
        return function (err) {
            console.log(("" + err).red);
            return process.exit(1);
        };
    })(this);
    
    Success = (function (_this) {
        return function (success) {
            console.log(("" + success).green);
            return process.exit(0);
        };
    })(this);
    
    Log = (function (_this) {
        return function (msg) {
            return console.log((" - " + msg).green);
        };
    })(this);
    
    Track = (function (superClass) {
        extend(Track, superClass);
        
        function Track(trackId, Spotify, directory, isMakeFolder, cb1, track1) {
            this.trackId = trackId;
            this.Spotify = Spotify;
            this.directory = directory;
            this.isMakeFolder = isMakeFolder;
            this.cb = cb1;
            this.track = track1 != null ? track1 : {};
            this.writeMetaData = bind(this.writeMetaData, this);
            this.downloadFile = bind(this.downloadFile, this);
            this.createDirs = bind(this.createDirs, this);
            this.getTrack = bind(this.getTrack, this);
            this.downloadCover = bind(this.downloadCover, this);
            this.getTrack();
        }
        
        Track.prototype.getTrack = function () {
            return this.Spotify.get(this.trackId, (function (_this) {
                return function (err, track) {
                    if (err) {
                        _this.invalid = true;
                        if (!err.toString().includes("404"))
                            _this.cb(err);
                        
                        _this.cb();
                    }
                    else {
                        return _this.Spotify.recurseAlternatives(track, "DE", (function (_err, newTrack) {
                            if (_err) {
                                _this.cb();
                            }
                            else {
                                _this.trackId = newTrack.uri;
                                return _this.Spotify.get(newTrack.uri, (function (__this) {
                                    return function (__err, _newTrack) {
                                        if (__err) {
                                            __this.cb();
                                        }
                                        else {
                                            __this.track = _newTrack;
                                            return __this.createDirs();
                                        }
                                    }
                                })(_this));
                            }
                        }));
                    };
                }
            })(this));
        };
        
        function fixFilename(filepath) {
            return filepath.replace(/[/\\?%*:|"<>]/g, '');
        }
        
        Track.prototype.createDirs = function () {
            var albumpath, artistpath, dir, filepath, stats;
            dir = Path.resolve("" + this.directory);
            if (this.isMakeFolder) {
                var artist_var = " ";
                if (this.track.artist[0] != undefined)
                    artist_var = this.track.artist[0].name;
                filepath = dir + '/' + fixFilename(artist_var.replace(/\//g, ' - ')) + ' - ' + fixFilename(this.track.name.replace(/\//g, ' - ')) + '.mp3';
            }
            else {
                artistpath = dir + '/' + fixFilename(this.track.artist[0].name.replace(/\//g, ' - ')) + '/';
                albumpath = artistpath + fixFilename(this.track.album.name.replace(/\//g, ' - ')) + ' [' + this.track.album.date.year + ']/';
                filepath = albumpath + fixFilename(this.track.artist[0].name.replace(/\//g, ' - ')) + ' - ' + fixFilename(this.track.name.replace(/\//g, ' - ')) + '.mp3';
            }
            if (fs.existsSync(filepath)) {
                stats = fs.statSync(filepath);
                if (stats.size !== 0) {
                    console.log(("Already Downloaded: " + this.track.artist[0].name + " " + this.track.name).yellow);
                    return this.cb();
                }
            }
            if (this.isMakeFolder) {
                if (!fs.existsSync(dir)) {
                    mkdirp.sync(dir);
                }
            }
            else {
                if (!fs.existsSync(albumpath)) {
                    mkdirp.sync(albumpath);
                }
            }
            this.downloadCover(filepath);
            return this.downloadFile(filepath);
        };
        
        Track.prototype.downloadFile = function (filepath) {
            var d, out, failed;
            Log("Downloading: " + this.track.artist[0].name + " - " + this.track.name);
            d = domain.create();
            d.on('error', (function (_this) {
                return function (err) {
                    if (err.toString().indexOf("Rate limited") > -1) {
                        failed = true;
                        out.end();
                        return null;
                    }
                    console.log((" - - " + (err.toString()) + " ...  { Skipping Track }").red);
                    return _this.cb();
                };
            })(this));
            return d.run((function (_this) {
                return function () {
                    out = fs.createWriteStream(filepath);
                    return _this.track.play().pipe(out).on('finish', function () {
                        if (failed) {
                            fs.unlinkSync(filepath);
                            setTimeout(function () { _this.downloadFile(filepath) }, 10000);
                            console.log((" - - Rate limited ...  { Retrying in 10 seconds }").red);
                            return null;
                        }
                        Log(" - DONE: " + _this.track.artist[0].name + " - " + _this.track.name);
                        return _this.writeMetaData(filepath);
                    });
                };
            })(this));
        };
        
        Track.prototype.downloadCover = function (filepath) {
            var httpreq = require('httpreq');
            var coverFilepath = filepath + ".jpg";
            var t = this.track;
            var url = this.Spotify.sourceUrls.LARGE + (t.album.coverGroup.image[2] ? t.album.coverGroup.image[2].uri : '').replace("undefined","");
            httpreq.download(
                url, 
                coverFilepath, 
                function (err, progress) {
                    if (err) return console.log(err);
                }, function (err, respose) {
                    if (err) return console.log(err);
                    Log("Cover Downloaded: " + t.artist[0].name + " - " + t.name);
                });
            return this.cb;
        };
        
        Track.prototype.writeMetaData = function (filepath) {
          
            var meta = {
                artist: this.track.artist[0].name,
                album: this.track.album.name,
                title: this.track.name,
                year: this.track.album.date.year.toString(),
                trackNumber: this.track.number.toString(),
                image: filepath + ".jpg"
            }
            
            id3.write(meta, filepath);
            fs.unlink(meta.image);
            return this.cb();
        };
        
        return Track;

    })(EventEmitter);
    
    Downloader = (function (superClass) {
        extend(Downloader, superClass);
        
        function Downloader(username, password, playlist, directory) {
            this.username = username;
            this.password = password;
            this.playlist = playlist;
            this.directory = directory;
            this.processTrack = bind(this.processTrack, this);
            this.processTracks = bind(this.processTracks, this);
            this.getPlaylist = bind(this.getPlaylist, this);
            this.attemptLogin = bind(this.attemptLogin, this);
            this.run = bind(this.run, this);
            this.Spotify = null;
            this.Tracks = [];
            this.dir = this.directory;
            this.makeFolder = false;
            this.generatePlaylist = false;
        }
        
        Downloader.prototype.run = function () {
            console.log('Downloader App Started..'.green);
            return async.series([this.attemptLogin, this.getPlaylist, this.processTracks], (function (_this) {
                return function (err, res) {
                    if (err) {
                        return Error("" + (err.toString()));
                    }
                    
                    return Success(' ------- DONE ALL ------- ');
                };
            })(this));
        };
        
        Downloader.prototype.attemptLogin = function (cb) {
            return SpotifyWeb.login(this.username, this.password, (function (_this) {
                return function (err, SpotifyInstance) {
                    if (err) {
                        return Error("Error logging in... (" + err + ")");
                    }
                    _this.Spotify = SpotifyInstance;
                    return typeof cb === "function" ? cb() : void 0;
                };
            })(this));
        };
        
        Downloader.prototype.getPlaylist = function (cb) {
            Log('Getting Playlist Data');
            return this.Spotify.playlist(this.playlist, 0, 9001, (function (_this) {
                return function (err, playlistData) {
                    if (err) {
                        return Error("Playlist data error... " + err);
                    }
                    Log("Got Playlist: " + playlistData.attributes.name);
                    if (_this.makeFolder) {
                        _this.dir = _this.directory + "/" + playlistData.attributes.name.replace(/\//g, '-') + '/';
                    }
                    _this.Tracks = lodash.map(playlistData.contents.items, function (item) {
                        return item.uri;
                    });
                    return typeof cb === "function" ? cb() : void 0;
                };
            })(this));
        };
        
        Downloader.prototype.processTracks = function (cb) {
            Log("Processing " + this.Tracks.length + " Tracks");
            return async.mapSeries(this.Tracks, this.processTrack, cb);
        };
        
        Downloader.prototype.processTrack = function (track, cb) {
            var TempInstance;
            TempInstance = new Track(track, this.Spotify, this.dir, this.makeFolder, cb);
            return TempInstance;
        };
        
        return Downloader;

    })(EventEmitter);
    
    Playlist = (function (superClass) {
        extend(Playlist, superClass);
        
        function Playlist() {
            this.addTrackToPlaylist = bind(this.addTrackToPlaylist, this);
            this.directory = null;
            this.name = null;
            this.playlistFile = null;
        }
        
        Playlist.prototype.addTrackToPlaylist = function () { };
        
        return Playlist;

    })(EventEmitter);
    
    module.exports = Downloader;

}).call(this);

//# sourceMappingURL=downloader.js.map
